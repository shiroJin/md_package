​	一个c语言编写的文件，需要经过以下四个步骤最后才能成为一个可执行文件。

1. 预处理
2. 编译
3. 汇编
4. 链接

​	可以简单的理解为1-3步骤是对代码语言的处理，将高级语言译成机器可以识别的机器语言。步骤4是将每个编译后的文件整合为一个完整的可执行文件。这里主要探究链接这步骤。

**ELF结构:**

​	下表为ELF文件主体结构，每个ELF文件都是由多个段组成的，一些复杂的elf文件会涵盖很多不同的段，一些简单的ELF文件可能只包括少数的段。这些都是由代码中数据决定的。

| Sections  | 描述                                   |
| --------- | -------------------------------------- |
| .text     | 全局变量/静态c变量                     |
| .data     | 未初始化和为0的全局变量/静态变量。     |
| .bss      | 未初始化的全局变量                     |
| .symtab   | 符号表                                 |
| .rel.text | 模块中引用或定义的全局函数的重定位信息 |
| .rel.data | 模块中引用或定义的全局变量的重定位信息 |
| .strtab   | 字符串表                               |
| ...       | 一些其他的段                           |

​	链接器的主要工作内容为两部分：

- **符号解析**

  将符号的引用和符号的定义关联起来，生成一个完整的符号表。

- **重定位**

  单个文件中引用的符号内存地址是不正确的，需要在链接过程中进行纠正。

## 静态链接器

#### 职责

* 输入：编译后的ELF文件

* 输出：将多个文件中引符号重定位，不同文件中相同段的合并，最后合成一个可执行文件

### 工作流程

**一、段空间和地址分配**

​	扫描所有的输入目标文件，收集所有目标文件的符号表到一个全局符号表中，将相同的段合并。在所有段合并成一个完整的文件后，符号的地址也随之可以确定下来。

![screenshot](/Users/mashiro_jin/Library/Group Containers/Q79WDW8YH9.com.evernote.Evernote/Evernote/quick-note/13630831-personal-app.yinxiang.com/quick-note-ap5jhC/attachment--NlsgIJ/screenshot.png)

<p style="text-align:center;font-style:italic;">section合并</p>
**二、符号解析**

​	每个编译文件中都有自己符号表，符号有些事静态的，有些是全局的。对于全局的，不同的文件定义的、引用的符号各不相同。全局变量的符号放在Common段中，静态变量放在bss段中，因为静态变量的大小是确定的，而全局变量因为弱类型进制的缘故，全局变量的符号大小时不确定的。对于静态的符号，段的地址确定后，静态符号的地址也就能确定。对于全局变量，不容的文件中可能定义了相同的符号，对于有冲突的符号需要做符号决议。然后确定符号的地址。

> **符号决议：**
> 	确定符号的定义，符号的定义有强弱之分，强符号覆盖弱符号。若在不同段中定义了相同的强符号，链接就会失败。

**三、符号重定位**

​	对于单个文件，引用了其他文件的符号，这个符号的地址是未确认的，只是一个占位符，但不是实际符号的地址。例如，一个文件中引用了foo函数，但是foo函数定义在其他文件中，当编译器编译这个文件时，编译器并不知道foo这个符号的地址。对于单个的ELF文件，foo函数这个符号是没有定义的。符号的重定位是链接器是主要工作内容。链接器将没有地址的符号赋予正确的地址。

​	符号重定位有两种方式，绝对寻址和相对寻址。

> A：保存在被修正位置的值
>
> B：被修正的位置（相对于段开始的偏移量或者虚拟地址）
>
> P：符号的实际地址
>
> * 绝对寻址 S+A
>
> * 相对寻址 S+A-P

**四、输出文件**

​	待所有符号重定位结束后，得到一个.out文件，一个可执行文件，文件中只有.bss，.text，.data段。没有符号表之类的段。

## 动态链接器

​	由于静态链接库在每个可执行文件中都有一份，导致了内存浪费的问题。如果可执行文件可以使用共享库就可以减少内存开支。动态链接库就是为了共享库而存在的，共享库的符号解析和重定位的工作由动态链接器完成。

​	![screenshot](/Users/mashiro_jin/Library/Group Containers/Q79WDW8YH9.com.evernote.Evernote/Evernote/quick-note/13630831-personal-app.yinxiang.com/quick-note-ap5jhC/attachment--VPMhOy/screenshot.png)

<p style="text-align: center;font-style: italic">动态库内存分配</p>
​	动态链接库的代码在多个进程间是共享的，动态库只会加载到内存中一次。当随后的进程链接动态库时不需要再次加载进内存，因此动态库到达了节省内存的作用。

​	共享库面临两个最基本的问题：

1、执行文件如何进行重定位

2、共享库数据是否会共享

​	动态链接器使用ipc代码——位置无关代码，使得共享库的符号地址可以更好的确定。全局变量、全局函数GOT、so模块内全局变量副本

​	同时，共享库带来的负面影响是复杂的GOT重定位会降低程序的启动速度——空间和时间的取舍在计算机中还是会常常面对。

优化方案：

一、延迟绑定PLT

plt item结构如下，

```c
foo@plt:
	jump *(foo@got)
	push offset
	jump PLT0
```

​	foo@got中存放着foo函数的地址，在程序加载时，foo@got的地址为下一条指令的地址，即执行push offset。PLT0为公共的重定位函数——_dl_runtime_resolve。_dl_runtime_resolve函数对入参函数进行重定位，并将重定位的地址写入foo@got。当第二次调用foo函数，将直接调转到foo函数的地址。这样的设计非常巧妙，一个符号的重定位过程只会发生一次，随后的调用无需再进行重定位。

​	动态符号表，

